// Copyright (c) 2015, the Fletch project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE.md file.

#include "platforms/stm/disco_fletch/src/uart.h"

#include <stdlib.h>

#include <stm32f7xx_hal.h>

#include "platforms/stm/disco_fletch/src/logger.h"

#include "src/shared/atomic.h"

#include "src/vm/hash_map.h"

#include "src/shared/platform.h"

// Reference to the instance in the code generated by STM32CubeMX.
extern UART_HandleTypeDef huart1;

// Bits set from interrupt handlers.
const int kReceivedBit = 1 << 0;
const int kTransmittedBit = 1 << 1;
const int kErrorBit = 1 << 2;
static fletch::Atomic<uint32_t> interrupt_flags;

const int kRxBufferSize = 511;
const int kTxBufferSize = 511;

Uart::Uart()
  : device(NULL, 0, this) {
  uart_ = &huart1;
  read_buffer_ = new CircularBuffer(kRxBufferSize);
  write_buffer_ = new CircularBuffer(kTxBufferSize);
}

fletch::HashMap<UART_HandleTypeDef*, Uart*> openUarts =
    fletch::HashMap<UART_HandleTypeDef*, Uart*>();

int Uart::Open() {
  ASSERT(port_id_ == 0);

  port_id_ = fletch::InstallDevice(&device);
  openUarts[uart_] = this;

  // Start receiving.
  HAL_UART_Receive_IT(uart_, &read_data_, 1);

  return port_id_;
}

size_t Uart::Read(uint8_t* buffer, size_t count) {
  return read_buffer_->Read(buffer, count, CircularBuffer::kDontBlock);
}

size_t Uart::Write(uint8_t* buffer, size_t count) {
  return write_buffer_->Write(buffer, count, CircularBuffer::kDontBlock);
}

void Uart::SendMessage(uint64_t message, uint32_t mask) {
  fletch::SendMessageCmsis(port_id_, message, mask);
}

Uart *GetUart(int port_id) {
  return reinterpret_cast<Uart*>(fletch::devices[port_id]->data);
}

void Uart::Task() {
  // Process notifications from the interrupt handlers.
//  for (;;) {
//    // Wait for an interrupt to be processed.
//    // osSemaphoreWait(semaphore_, osWaitForever);
//    // Read the flags and set them to zero.
//    uint32_t flags = interrupt_flags.exchange(0);
//
//    if ((flags & kReceivedBit) != 0) {
//      // Don't block when writing to the buffer. Buffer overrun will
//      // cause lost data.
//      read_buffer_->Write(&read_data_, 1, CircularBuffer::kDontBlock);
//
//      // Start receiving of next byte.
//      HAL_StatusTypeDef status = HAL_UART_Receive_IT(uart_, &read_data_, 1);
//      if (status != HAL_OK) {
//        LOG_ERROR("%d\n", status);
//      }
//    }
//
//    if ((flags & kTransmittedBit) != 0) {
//      fletch::ScopedLock lock(tx_mutex_);
//      tx_pending_ = false;
//      EnsureTransmission();
//    }
//
//    if ((flags & kErrorBit) != 0) {
//      // Ignore errors for now.
//      error_count_++;
//      error = 0;
//      // Setup interrupt for next byte.
//      HAL_StatusTypeDef status = HAL_UART_Receive_IT(uart_, &read_data_, 1);
//      if (status != HAL_OK) {
//        LOG_ERROR("%d\n", status);
//      }
//    }
//    // Send a message to listening ports.
//    fletch::SendMessageCmsis(uart->port_id_, mask, mask);
//  }
}

void Uart::EnsureTransmission() {
  if (!tx_pending_) {
    // Don't block when there is nothing to send.
    int bytes = tx_buffer_->Read(
        tx_data_, kTxBlockSize, CircularBuffer::kDontBlock);
    if (bytes > 0) {
      HAL_StatusTypeDef status = HAL_UART_Transmit_IT(uart_, tx_data_, bytes);
      if (status != HAL_OK) {
        LOG_ERROR("%d\n", status);
      }
      tx_pending_ = true;
    }
  }
}

// Shared return from interrupt handler. Will set the specified flag
// and transfer control to the thread handling interrupts.
void ReturnFromInterrupt(UART_HandleTypeDef *huart, uint32_t flag) {
  // Set the requested bit.
  uint32_t flags = interrupt_flags;
  uint32_t new_flags = flags |= flag;
  bool success = false;
  while (!success) {
    success =
        interrupt_flags.compare_exchange_weak(flags, new_flags);
  }

  Uart *uart = openUarts[huart];
  uart->SendMessage(new_flags, new_flags);
}

extern "C" void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
  ReturnFromInterrupt(huart, kReceivedBit);
}

extern "C" void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
  ReturnFromInterrupt(huart, kTransmittedBit);
}

extern "C" void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
    HAL_UART_GetError(huart);

  // Clear all errors.
  __HAL_UART_CLEAR_OREFLAG(huart);
  __HAL_UART_CLEAR_FEFLAG(huart);
  __HAL_UART_CLEAR_PEFLAG(huart);
  __HAL_UART_CLEAR_NEFLAG(huart);

  ReturnFromInterrupt(huart, kErrorBit);
}
