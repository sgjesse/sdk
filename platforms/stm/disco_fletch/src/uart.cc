// Copyright (c) 2015, the Fletch project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE.md file.

#include "platforms/stm/disco_fletch/src/uart.h"

#include <stdlib.h>

#include <stm32f7xx_hal.h>

#include <task.h>

#include "platforms/stm/disco_fletch/src/logger.h"

#include "src/shared/atomic.h"

#include "src/vm/hash_map.h"

#include "src/shared/platform.h"

// Reference to the instance in the code generated by STM32CubeMX.
extern UART_HandleTypeDef huart1;

// Bits set from interrupt handlers.
const int kReceivedBit = 1 << 0;
const int kTransmittedBit = 1 << 1;
const int kErrorBit = 1 << 2;

const int kRxBufferSize = 511;
const int kTxBufferSize = 511;

Uart::Uart() : device_(NULL, 0, this) {
  uart_ = &huart1;
  read_buffer_ = new CircularBuffer(kRxBufferSize);
  write_buffer_ = new CircularBuffer(kTxBufferSize);
  tx_pending_ = false;
  interrupt_flags.store(0);
  tx_mutex_ = fletch::Platform::CreateMutex();
  semaphore_ = xSemaphoreCreateCounting(3, 0);
}

fletch::HashMap<UART_HandleTypeDef*, Uart*> openUarts =
    fletch::HashMap<UART_HandleTypeDef*, Uart*>();

void UartTask(void *arg) {
  reinterpret_cast<Uart*>(arg)->Task();
}

int Uart::Open() {
  ASSERT(port_id_ == 0);

  port_id_ = fletch::InstallDevice(&device_);
  openUarts[uart_] = this;

  TaskHandle_t handle;
  xTaskCreate(UartTask, "Uart", 1024, this, configMAX_PRIORITIES - 1, &handle);

  // Start receiving.
  HAL_UART_Receive_IT(uart_, &read_data_, 1);

  return port_id_;
}

size_t Uart::Read(uint8_t* buffer, size_t count) {
  return read_buffer_->Read(buffer, count, CircularBuffer::kDontBlock);
}

size_t Uart::Write(uint8_t* buffer, size_t count) {
  size_t written_count =
      write_buffer_->Write(buffer, count, CircularBuffer::kDontBlock);
  if (written_count > 0) {
    EnsureTransmission();
  }
  return written_count;
}

void Uart::EnsureTransmission() {
  if (!tx_pending_) {
    // Don't block when there is nothing to send.
    int bytes = write_buffer_->Read(
        tx_data_, kTxBlockSize, CircularBuffer::kDontBlock);
    if (bytes > 0) {
      HAL_StatusTypeDef status = HAL_UART_Transmit_IT(uart_, tx_data_, bytes);
      if (status != HAL_OK) {
        LOG_ERROR("%d\n", status);
      }
      tx_pending_ = true;
    }
  }
}

void Uart::Task() {
  // Process notifications from the interrupt handlers.
  for (;;) {
    // Wait for an interrupt to be processed.
    printf("Waiting\n");
    xSemaphoreTake(semaphore_, portMAX_DELAY);
    uint32_t flags = interrupt_flags.exchange(0);
    printf("Waking up %d\n", flags);
    if ((flags & kReceivedBit) != 0) {
      // Don't block when writing to the buffer. Buffer overrun will
      // cause lost data.
      read_buffer_->Write(&read_data_, 1, CircularBuffer::kDontBlock);
      printf("Setting up new read\n");
      HAL_StatusTypeDef status = HAL_UART_Receive_IT(uart_, &read_data_, 1);
      if (status != HAL_OK) {
        LOG_ERROR("%d\n", status);
      }
      SendMessage(flags);
    }
    if ((flags & kTransmittedBit) != 0) {
      fletch::ScopedLock lock(tx_mutex_);
      tx_pending_ = false;
      EnsureTransmission();
      if (!write_buffer_->IsFull()) {
        SendMessage(flags);
      }
    }
    // XXX handle errors.
  }
}

void Uart::SendMessage(uint32_t msg) {
  printf("Sending message %d\n", msg);
  fletch::SendMessageCmsis(port_id_, msg, msg);
}

Uart *GetUart(int port_id) {
  return reinterpret_cast<Uart*>(fletch::devices[port_id]->data);
}

// Shared return from interrupt handler. Will set the specified flag
// and transfer control to the event handler.
void Uart::ReturnFromInterrupt(uint32_t flag) {
  // Set the requested bit.
  uint32_t flags = interrupt_flags;
  bool success = false;
  while (!success) {
    uint32_t new_flags = flags | flag;
    success = interrupt_flags.compare_exchange_weak(flags, new_flags);
  }

  // Pass control to the thread handling interrupts.
  portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
  xSemaphoreGiveFromISR(semaphore_, &xHigherPriorityTaskWoken);
  portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
}

extern "C" void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
  printf("rxcallback\n");
  Uart *uart = openUarts[huart];
  uart->ReturnFromInterrupt(kReceivedBit);
}

extern "C" void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) {
//  printf("txcallback\n");
  Uart *uart = openUarts[huart];
  uart->ReturnFromInterrupt(kTransmittedBit);
}

extern "C" void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
    HAL_UART_GetError(huart);

  // Clear all errors.
  __HAL_UART_CLEAR_OREFLAG(huart);
  __HAL_UART_CLEAR_FEFLAG(huart);
  __HAL_UART_CLEAR_PEFLAG(huart);
  __HAL_UART_CLEAR_NEFLAG(huart);
}
